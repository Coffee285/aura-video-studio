<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Contributing to Aura Video Studio | Aura Video Studio </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Contributing to Aura Video Studio | Aura Video Studio ">
      
      
      <link rel="icon" href="favicon.ico">
      <link rel="stylesheet" href="public/docfx.min.css">
      <link rel="stylesheet" href="public/main.css">
      <meta name="docfx:navrel" content="toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="">
      
      
      <meta name="docfx:docurl" content="https://github.com/Coffee285/aura-video-studio/blob/main/CONTRIBUTING.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="index.html">
            <img id="logo" class="svg" src="logo.svg" alt="Aura Video Studio">
            Aura Video Studio
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="contributing-to-aura-video-studio">Contributing to Aura Video Studio</h1>

<p>Thank you for your interest in contributing to Aura Video Studio! This guide outlines the development workflow and standards for the project.</p>
<h2 id="platform-requirements">Platform Requirements</h2>
<p><strong>Aura Video Studio is an Electron desktop application targeting Windows 11 (x64) primarily, with cross-platform capability.</strong></p>
<p>While the application is designed to support Windows, macOS, and Linux through Electron, the current primary focus is Windows 11 (64-bit).</p>
<p><strong>Development Prerequisites:</strong></p>
<ul>
<li><strong>Node.js 20.0.0 or higher</strong> for all JavaScript/TypeScript components (Aura.Web frontend and Aura.Desktop Electron app)</li>
<li><strong>.NET 8 SDK</strong> for backend components</li>
<li><strong>npm 9.0.0 or higher</strong></li>
<li><strong>Git</strong> with long paths enabled (Windows)</li>
<li><strong>FFmpeg 4.0+</strong> for video rendering</li>
<li><strong>Windows 11</strong> recommended for Windows-specific builds</li>
</ul>
<p><strong>Cross-Platform Development:</strong></p>
<ul>
<li><strong>Backend (.NET)</strong>: Fully cross-platform (Windows, macOS, Linux)</li>
<li><strong>Frontend (React)</strong>: Fully cross-platform</li>
<li><strong>Electron</strong>: Cross-platform framework</li>
<li><strong>Installers</strong>: Platform-specific builds (electron-builder)</li>
</ul>
<p><strong>See the complete setup guide:</strong> <a href="BUILD_GUIDE.html">BUILD_GUIDE.md</a></p>
<h2 id="development-standards">Development Standards</h2>
<h3 id="no-placeholder-policy">No Placeholder Policy</h3>
<p>This project maintains a <strong>zero-tolerance policy for placeholder markers</strong> in source code. All code committed must be production-ready with no future work markers.</p>
<h4 id="forbidden-comment-patterns">Forbidden Comment Patterns</h4>
<p>The following comment patterns are <strong>strictly prohibited</strong> in source code:</p>
<ul>
<li><code>// TODO</code></li>
<li><code>// FIXME</code></li>
<li><code>// HACK</code></li>
<li><code>// XXX</code></li>
<li><code>// WIP</code></li>
<li><code>/* TODO</code></li>
<li><code>/* FIXME</code></li>
<li><code>/* HACK</code></li>
<li><code>/* WIP</code></li>
</ul>
<p><strong>Note:</strong> General comments about &quot;future enhancements&quot; or &quot;planned features&quot; in regular prose are acceptable. This policy specifically targets code comment markers that indicate incomplete work.</p>
<h4 id="enforcement">Enforcement</h4>
<p><strong>Automated checks:</strong></p>
<pre><code class="lang-bash"># Scan for placeholder markers
node scripts/audit/find-placeholders.js
</code></pre>
<p><strong>Pre-commit hooks:</strong></p>
<ul>
<li>Git hooks automatically run before each commit</li>
<li>Commits with placeholder markers will be rejected</li>
<li>Located in <code>.husky/pre-commit</code></li>
</ul>
<p><strong>CI/CD validation:</strong></p>
<ul>
<li>All PRs are automatically scanned</li>
<li>PRs with placeholders will fail CI checks</li>
<li>See <code>.github/workflows/build-validation.yml</code></li>
</ul>
<p><strong>To bypass hooks</strong> (not recommended, CI will still catch it):</p>
<pre><code class="lang-bash">git commit --no-verify -m &quot;message&quot;
</code></pre>
<ul>
<li>Detailed reporting with verbose mode</li>
</ul>
<p><strong>Usage:</strong></p>
<pre><code class="lang-powershell"># Run the audit
pwsh scripts/audit/no_future_text.ps1

# Run with verbose output
pwsh scripts/audit/no_future_text.ps1 -Verbose
</code></pre>
<h4 id="allowed-exceptions">Allowed Exceptions</h4>
<p>The following types of files are allowed to contain these phrases:</p>
<ul>
<li>Meta-documentation about the cleanup process itself</li>
<li>User-facing instructional guides with &quot;Next Steps&quot; for users</li>
<li>CI documentation explaining workflow patterns</li>
</ul>
<p>See the <code>$AllowedFiles</code> array in <code>scripts/audit/no_future_text.ps1</code> for the complete list.</p>
<h3 id="ci-integration">CI Integration</h3>
<p>The audit script runs automatically in CI pipelines:</p>
<ul>
<li><strong>Windows CI</strong> (<code>.github/workflows/ci-windows.yml</code>)</li>
<li><strong>Linux CI</strong> (<code>.github/workflows/ci-linux.yml</code>)</li>
<li><strong>No Placeholders Workflow</strong> (<code>.github/workflows/no-placeholders.yml</code>)</li>
</ul>
<p>Pull requests that introduce forbidden placeholder text will fail the CI checks.</p>
<h3 id="what-to-do-instead">What to Do Instead</h3>
<p>Instead of adding placeholder text:</p>
<ol>
<li><strong>For unimplemented features:</strong> Don't mention them in documentation until they're implemented</li>
<li><strong>For work in progress:</strong> Use feature branches and don't merge until complete</li>
<li><strong>For improvements:</strong> Document only what currently exists; file GitHub issues for future work</li>
<li><strong>For user instructions:</strong> Use &quot;To continue:&quot; or &quot;To complete:&quot; instead of &quot;Next steps:&quot;</li>
</ol>
<h2 id="building-and-testing">Building and Testing</h2>
<p>See <a href="BUILD_GUIDE.html">BUILD_GUIDE.md</a> for detailed build instructions.</p>
<h3 id="quick-start">Quick Start</h3>
<p><strong>Desktop App Build:</strong></p>
<pre><code class="lang-bash"># Install dependencies
cd Aura.Web &amp;&amp; npm install
cd ../Aura.Desktop &amp;&amp; npm install

# Build frontend
cd ../Aura.Web &amp;&amp; npm run build:prod

# Build backend
cd ../Aura.Api &amp;&amp; dotnet build -c Release

# Run Electron app
cd ../Aura.Desktop &amp;&amp; npm run dev
</code></pre>
<p><strong>Component Development:</strong></p>
<pre><code class="lang-bash"># Terminal 1: Backend
cd Aura.Api &amp;&amp; dotnet watch run

# Terminal 2: Frontend
cd Aura.Web &amp;&amp; npm run dev
</code></pre>
<p><strong>Testing:</strong></p>
<pre><code class="lang-bash"># Frontend tests
cd Aura.Web
npm test

# Backend tests
dotnet test

# E2E tests
cd Aura.Web
npm run playwright
</code></pre>
<h3 id="end-to-end-testing">End-to-End Testing</h3>
<p>The project includes comprehensive E2E tests using Playwright.</p>
<h4 id="running-e2e-tests-locally">Running E2E Tests Locally</h4>
<pre><code class="lang-bash">cd Aura.Web

# Install Playwright browsers (first time only)
npm run playwright:install

# Run all E2E tests
npm run playwright

# Run specific test suites
npx playwright test tests/e2e/full-pipeline.spec.ts

# Run with UI mode for debugging
npm run playwright:ui
</code></pre>
<ol start="3">
<li><p><strong>Memory Regression Tests</strong> (<code>memory-regression.spec.ts</code>):</p>
<ul>
<li>Memory leak detection during pagination</li>
<li>Performance with large datasets</li>
<li>Event listener cleanup</li>
<li>Resource cleanup after job completion</li>
</ul>
</li>
<li><p><strong>Complete Workflow Tests</strong> (<code>complete-workflow.spec.ts</code>):</p>
<ul>
<li>Full video generation flow</li>
<li>Error recovery</li>
<li>Progress tracking</li>
</ul>
</li>
</ol>
<h4 id="testing-with-mocked-providers-fast">Testing with Mocked Providers (Fast)</h4>
<p>The E2E tests use mocked providers by default for fast, deterministic execution:</p>
<pre><code class="lang-bash"># Tests run with mocked responses
npm run playwright
</code></pre>
<h4 id="testing-with-docker-compose-full-stack">Testing with Docker Compose (Full Stack)</h4>
<p>For full integration testing locally:</p>
<pre><code class="lang-bash"># Start services with docker-compose
docker-compose -f docker-compose.test.yml up --build

# Run E2E tests against local stack
PLAYWRIGHT_BASE_URL=http://localhost:5005 npm run playwright

# Stop services
docker-compose -f docker-compose.test.yml down
</code></pre>
<h4 id="memory-and-performance-testing">Memory and Performance Testing</h4>
<p>Memory regression tests check for leaks and performance degradation:</p>
<pre><code class="lang-bash"># Run memory tests with heap profiling
npx playwright test tests/e2e/memory-regression.spec.ts --project=chromium

# View memory test results
cat Aura.Web/test-results/memory-regression-*.txt
</code></pre>
<p><strong>Memory test thresholds</strong>:</p>
<ul>
<li>Memory growth during scrolling: &lt;50%</li>
<li>Template rendering time: &lt;5s for 1000 items</li>
<li>Virtualized items rendered: &lt;100 (out of 1000)</li>
</ul>
<h3 id="integration-testing">Integration Testing</h3>
<p>Backend integration tests validate end-to-end flows:</p>
<pre><code class="lang-bash"># Run integration tests only
dotnet test --filter &quot;FullyQualifiedName~Integration&quot;

# Run with detailed output
dotnet test --filter &quot;FullyQualifiedName~Integration&quot; --logger &quot;console;verbosity=detailed&quot;
</code></pre>
<h2 id="code-quality">Code Quality</h2>
<ul>
<li><strong>Line Coverage:</strong> Maintain at least 60% line coverage for .NET code</li>
<li><strong>Web Coverage:</strong> Maintain at least 70% coverage for tested files</li>
<li><strong>Build Warnings:</strong> Fix new warnings introduced by your changes</li>
<li><strong>Analyzer Rules:</strong> Follow the analyzer rules defined in <code>Directory.Build.props</code></li>
<li><strong>ESLint:</strong> All code must pass ESLint with zero warnings and errors</li>
</ul>
<h3 id="linting-standards-frontend">Linting Standards (Frontend)</h3>
<p>The frontend codebase enforces strict ESLint rules with <code>--max-warnings 0</code>. All code must pass linting before merging.</p>
<h4 id="running-lint-checks">Running Lint Checks</h4>
<pre><code class="lang-bash"># Check for errors and warnings
cd Aura.Web
npm run lint

# Auto-fix fixable issues
npm run lint:fix

# Type check
npm run type-check

# Run all quality checks
npm run quality-check
</code></pre>
<h4 id="common-linting-patterns">Common Linting Patterns</h4>
<p><strong>1. Avoid <code>any</code> Types</strong></p>
<pre><code class="lang-typescript">// ‚ùå Bad
const handler = (event: any) =&gt; { };

// ‚úÖ Good  
const handler = (event: React.MouseEvent&lt;HTMLButtonElement&gt;) =&gt; { };
</code></pre>
<p><strong>2. React Hooks Dependencies</strong></p>
<pre><code class="lang-typescript">// ‚ùå Bad - missing dependencies
useEffect(() =&gt; {
  loadData();
}, []);

// ‚úÖ Good - include all dependencies
const loadData = useCallback(async () =&gt; {
  // ...
}, [dependency1, dependency2]);

useEffect(() =&gt; {
  loadData();
}, [loadData]);
</code></pre>
<p><strong>3. Accessibility</strong></p>
<pre><code class="lang-typescript">// ‚ùå Bad - div with onClick but no keyboard support
&lt;div onClick={handler}&gt;Click me&lt;/div&gt;

// ‚úÖ Good - use semantic HTML
&lt;button onClick={handler}&gt;Click me&lt;/button&gt;

// ‚úÖ Also acceptable - div with proper ARIA
&lt;div 
  role=&quot;button&quot;
  tabIndex={0}
  onClick={handler}
  onKeyDown={(e) =&gt; e.key === 'Enter' &amp;&amp; handler()}
&gt;
  Click me
&lt;/div&gt;
</code></pre>
<p><strong>4. Console Statements</strong></p>
<pre><code class="lang-typescript">// ‚ùå Bad - debug console.log
console.log('Debug info:', data);

// ‚úÖ Good - use allowed console methods (error, warn, info)
console.error('Error occurred:', error);

// ‚úÖ Good - conditional debug logging with disable comment
if (process.env.NODE_ENV === 'development') {
  // eslint-disable-next-line no-console
  console.log('Debug info:', data);
}
</code></pre>
<p><strong>5. Unused Variables</strong></p>
<pre><code class="lang-typescript">// ‚ùå Bad
const [value, setValue] = useState(0);
// setValue is never used

// ‚úÖ Good - prefix with underscore if intentionally unused
const [value, _setValue] = useState(0);

// ‚úÖ Better - don't destructure if not needed
const value = useState(0)[0];
</code></pre>
<h4 id="eslint-disable-comments">ESLint Disable Comments</h4>
<p>When you need to disable a rule, always provide a justification:</p>
<pre><code class="lang-typescript">// Dialog needs to be focusable for keyboard accessibility
// eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex
tabIndex={0}
</code></pre>
<h2 id="architectural-patterns">Architectural Patterns</h2>
<p>Aura Video Studio follows specific architectural patterns to ensure code quality and maintainability. Violating these patterns may result in PR rejection.</p>
<h3 id="key-resources">Key Resources</h3>
<p>üìö <strong>Read these documents before contributing:</strong></p>
<ul>
<li><strong><a href="docs/ARCHITECTURE_DECISIONS.html">docs/ARCHITECTURE_DECISIONS.md</a></strong> - Explains <em>why</em> we made certain architectural choices</li>
<li><strong><a href="docs/COMMON_PITFALLS.html">docs/COMMON_PITFALLS.md</a></strong> - Lists common mistakes and anti-patterns to avoid</li>
</ul>
<h3 id="core-principles">Core Principles</h3>
<ol>
<li><p><strong>No Reflection for Dependency Access</strong></p>
<ul>
<li>‚ùå Never use <code>GetField()</code> or <code>GetProperty()</code> to access private members of dependencies</li>
<li>‚úÖ Use proper dependency injection with interfaces</li>
<li>Example: Use <code>IOllamaDirectClient</code> instead of reflecting into <code>OllamaLlmProvider</code></li>
</ul>
</li>
<li><p><strong>React Component Refs over QuerySelectors</strong></p>
<ul>
<li>‚ùå Never use <code>querySelector</code> with Fluent UI class names (they're hashed and change between builds)</li>
<li>‚úÖ Use React refs for stable DOM element access</li>
<li>Example: <code>const ref = useRef&lt;HTMLDivElement&gt;(null)</code> then <code>&lt;div ref={ref}&gt;</code></li>
</ul>
</li>
<li><p><strong>Atomic Job State Updates</strong></p>
<ul>
<li>‚ùå Never set job status to &quot;completed&quot; without providing <code>outputPath</code></li>
<li>‚úÖ Always update status and outputPath together atomically</li>
<li>Example: <code>UpdateJobStatusAsync(id, &quot;completed&quot;, 100, outputPath: &quot;/path/to/file&quot;)</code></li>
</ul>
</li>
<li><p><strong>Video Preview Synchronization</strong></p>
<ul>
<li>‚ùå Don't check <code>isPlaying</code> before syncing video position</li>
<li>‚úÖ Always sync video element time, even when paused (for seek support)</li>
<li>Example: <code>playbackStore.setCurrentTime(video.currentTime)</code> (no <code>isPlaying</code> check)</li>
</ul>
</li>
<li><p><strong>SSE Connection Best Practices</strong></p>
<ul>
<li>‚ùå Don't use fixed delays before connecting to SSE</li>
<li>‚úÖ Connect immediately with timeout and polling fallback</li>
<li>‚úÖ Implement exponential backoff for polling when SSE fails</li>
</ul>
</li>
</ol>
<h3 id="code-review-checklist">Code Review Checklist</h3>
<p>Before submitting your PR, ensure:</p>
<ul>
<li>[ ] No use of reflection to access private fields (use DI interfaces instead)</li>
<li>[ ] No <code>querySelector</code> with Fluent UI class names (use refs)</li>
<li>[ ] Job status &quot;completed&quot; transitions include <code>outputPath</code></li>
<li>[ ] Video synchronization works when paused (not just playing)</li>
<li>[ ] SSE connections have timeout and graceful fallback</li>
<li>[ ] All async job operations check BOTH status AND outputPath for completion</li>
<li>[ ] Error handling uses <code>unknown</code> type, not <code>any</code></li>
<li>[ ] No <code>.Result</code> or <code>.Wait()</code> on async methods in C#</li>
</ul>
<h2 id="pull-request-guidelines">Pull Request Guidelines</h2>
<h3 id="before-submitting-a-pr">Before Submitting a PR</h3>
<p>Run the following checks locally to ensure your PR will pass CI:</p>
<pre><code class="lang-bash"># 1. Scan for placeholder markers
node scripts/audit/find-placeholders.js

# 2. Lint and type check frontend
cd Aura.Web
npm run lint
npm run typecheck
npm run format:check
cd ..

# 3. Build the solution
dotnet build Aura.sln --configuration Release

# 4. Build the frontend
cd Aura.Web
npm run build
cd ..

# 5. Run all tests
dotnet test
cd Aura.Web
npm test
cd ..
</code></pre>
<h3 id="pr-checklist">PR Checklist</h3>
<p>Before submitting your pull request, ensure:</p>
<ul>
<li>[ ] <strong>No placeholder markers</strong> - No TODO/FIXME/HACK comments in code</li>
<li>[ ] <strong>All linting passes</strong> - <code>npm run lint</code> shows 0 errors and 0 warnings</li>
<li>[ ] <strong>All type checking passes</strong> - <code>npm run typecheck</code> shows 0 errors</li>
<li>[ ] <strong>All tests pass</strong> - Both .NET and frontend tests complete successfully</li>
<li>[ ] <strong>Build succeeds</strong> - Clean build on Windows 11</li>
<li>[ ] <strong>Documentation updated</strong> - If you changed user-facing features</li>
<li>[ ] <strong>Code formatted</strong> - Follows .editorconfig and runs formatters</li>
<li>[ ] <strong>Focused changes</strong> - One feature/fix per PR</li>
<li>[ ] <strong>Complete implementation</strong> - Features are fully implemented, not partial</li>
</ul>
<h3 id="pr-requirements">PR Requirements</h3>
<p>All PRs must:</p>
<ol>
<li><strong>Pass all CI checks</strong> (5 required jobs must pass)</li>
<li><strong>Have clear description</strong> explaining what and why</li>
<li><strong>Reference related issues</strong> if applicable</li>
<li><strong>Include tests</strong> for new functionality</li>
<li><strong>Maintain code coverage</strong> at current levels or higher</li>
</ol>
<h3 id="ci-checks-that-will-run">CI Checks That Will Run</h3>
<p>Your PR will automatically trigger:</p>
<ol>
<li><strong>Windows Build Test</strong> - Full build on Windows</li>
<li><strong>.NET Build Test</strong> - Strict build with warnings checked</li>
<li><strong>Lint and Type Check</strong> - Code quality validation</li>
<li><strong>Placeholder Scan</strong> - Zero-tolerance for markers</li>
<li><strong>Environment Validation</strong> - Node.js/npm version checks</li>
</ol>
<p><strong>All 5 must pass</strong> before your PR can be merged.</p>
<h2 id="getting-help">Getting Help</h2>
<ul>
<li>Review existing documentation in the <code>docs/</code> directory</li>
<li>Check the <a href="docs/developer/BUILD_GUIDE.html">BUILD_GUIDE.md</a> for setup help</li>
<li>Examine existing code patterns for guidance</li>
<li>File issues for questions or discussions</li>
</ul>
<hr>
<p><strong>Remember:</strong> If it's not implemented, don't document it. This keeps the project credible and maintainable.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Coffee285/aura-video-studio/blob/main/CONTRIBUTING.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          ¬© 2025 Aura Video Studio. Documentation built with DocFX.
        </div>
      </div>
    </footer>
  </body>
</html>
