<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Test Writing Guide | Aura Video Studio </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Test Writing Guide | Aura Video Studio ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/Coffee285/aura-video-studio/blob/main/docs/testing/TEST_WRITING_GUIDE.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="Aura Video Studio">
            Aura Video Studio
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="test-writing-guide">Test Writing Guide</h1>

<p>This guide provides best practices and patterns for writing tests in the Aura project.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#test-structure">Test Structure</a></li>
<li><a href="#backend-testing-net">Backend Testing (.NET)</a></li>
<li><a href="#frontend-testing-react">Frontend Testing (React)</a></li>
<li><a href="#test-data-builders">Test Data Builders</a></li>
<li><a href="#integration-tests">Integration Tests</a></li>
<li><a href="#performance-tests">Performance Tests</a></li>
<li><a href="#best-practices">Best Practices</a></li>
</ul>
<h2 id="test-structure">Test Structure</h2>
<h3 id="test-organization">Test Organization</h3>
<pre><code>Aura.Tests/
├── TestDataBuilders/      # Reusable test data builders
├── Integration/           # Integration test suites
│   ├── EndpointTests/    # API endpoint tests
│   └── *.cs              # Base classes
├── Performance/          # Performance test suites
└── *.cs                  # Unit tests (colocated with tested code)

Aura.Web/
├── src/
│   ├── test/
│   │   ├── utils/        # Test utilities
│   │   ├── setup.ts      # Global test setup
│   │   └── *.test.tsx    # Unit tests
│   └── **/__tests__/     # Tests colocated with code
└── tests/
    ├── e2e/              # End-to-end tests
    ├── integration/      # Integration tests
    └── smoke/            # Smoke tests
</code></pre>
<h3 id="naming-conventions">Naming Conventions</h3>
<h4 id="backend-net">Backend (.NET)</h4>
<pre><code class="lang-csharp">// File: ServiceNameTests.cs
public class ServiceNameTests
{
    [Fact]
    public void MethodName_Scenario_ExpectedBehavior()
    {
        // Arrange
        // Act
        // Assert
    }
}
</code></pre>
<h4 id="frontend-typescript">Frontend (TypeScript)</h4>
<pre><code class="lang-typescript">// File: ComponentName.test.tsx
describe('ComponentName', () =&gt; {
  it('should render correctly', () =&gt; {
    // Arrange
    // Act
    // Assert
  });
  
  it('should handle user interaction', async () =&gt; {
    // Arrange
    // Act
    // Assert
  });
});
</code></pre>
<h2 id="backend-testing-net">Backend Testing (.NET)</h2>
<h3 id="unit-tests-with-xunit">Unit Tests with xUnit</h3>
<pre><code class="lang-csharp">using Aura.Tests.TestDataBuilders;
using FluentAssertions;
using Moq;
using Xunit;

public class VideoServiceTests
{
    private readonly Mock&lt;IVideoRepository&gt; _mockRepository;
    private readonly VideoService _sut; // System Under Test

    public VideoServiceTests()
    {
        _mockRepository = new Mock&lt;IVideoRepository&gt;();
        _sut = new VideoService(_mockRepository.Object);
    }

    [Fact]
    public async Task ProcessVideo_WithValidInput_ReturnsSuccess()
    {
        // Arrange
        var job = new VideoJobBuilder()
            .WithProjectId(&quot;test-123&quot;)
            .Build();
        
        _mockRepository
            .Setup(r =&gt; r.SaveAsync(It.IsAny&lt;VideoJob&gt;()))
            .ReturnsAsync(true);

        // Act
        var result = await _sut.ProcessVideoAsync(job);

        // Assert
        result.Should().BeTrue();
        _mockRepository.Verify(r =&gt; r.SaveAsync(job), Times.Once);
    }

    [Theory]
    [InlineData(null)]
    [InlineData(&quot;&quot;)]
    [InlineData(&quot;   &quot;)]
    public async Task ProcessVideo_WithInvalidProjectId_ThrowsException(string? projectId)
    {
        // Arrange
        var job = new VideoJobBuilder()
            .WithProjectId(projectId!)
            .Build();

        // Act &amp; Assert
        await Assert.ThrowsAsync&lt;ArgumentException&gt;(
            () =&gt; _sut.ProcessVideoAsync(job)
        );
    }
}
</code></pre>
<h3 id="integration-tests">Integration Tests</h3>
<pre><code class="lang-csharp">using Aura.Tests.Integration;
using Microsoft.AspNetCore.Mvc.Testing;
using System.Net.Http.Json;
using Xunit;

public class ProjectsApiTests : ApiIntegrationTestBase
{
    public ProjectsApiTests(WebApplicationFactory&lt;Program&gt; factory) 
        : base(factory)
    {
    }

    [Fact]
    public async Task CreateProject_ReturnsCreatedProject()
    {
        // Arrange
        var request = new CreateProjectRequest
        {
            Name = &quot;Test Project&quot;,
            Description = &quot;Integration test&quot;
        };

        // Act
        var response = await PostAsync&lt;CreateProjectRequest, ProjectDto&gt;(
            &quot;/api/projects&quot;, 
            request
        );

        // Assert
        Assert.NotNull(response);
        Assert.Equal(request.Name, response.Name);
    }
}
</code></pre>
<h3 id="using-test-data-builders">Using Test Data Builders</h3>
<pre><code class="lang-csharp">// Simple usage
var project = new ProjectBuilder().Build();

// Customized
var project = new ProjectBuilder()
    .WithName(&quot;My Project&quot;)
    .WithOwnerId(&quot;user-123&quot;)
    .WithTag(&quot;tutorial&quot;)
    .Archived()
    .Build();

// Complex scenarios
var timeline = new TimelineBuilder()
    .WithDuration(120.0)
    .WithTrack(new TrackBuilder()
        .WithType(TrackType.Video)
        .WithClip(new ClipBuilder()
            .AtTime(0.0)
            .WithDuration(5.0)
            .Build())
        .Build())
    .Build();
</code></pre>
<h2 id="frontend-testing-react">Frontend Testing (React)</h2>
<h3 id="component-tests">Component Tests</h3>
<pre><code class="lang-typescript">import { renderWithProviders, screen, userEvent } from '@/test/utils/testUtils';
import { MyComponent } from './MyComponent';

describe('MyComponent', () =&gt; {
  it('should render with props', () =&gt; {
    renderWithProviders(&lt;MyComponent title=&quot;Test&quot; /&gt;);
    
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  it('should handle button click', async () =&gt; {
    const onClickMock = jest.fn();
    const user = userEvent.setup();
    
    renderWithProviders(&lt;MyComponent onClick={onClickMock} /&gt;);
    
    await user.click(screen.getByRole('button'));
    
    expect(onClickMock).toHaveBeenCalledTimes(1);
  });

  it('should display loading state', () =&gt; {
    renderWithProviders(&lt;MyComponent isLoading /&gt;);
    
    expect(screen.getByRole('progressbar')).toBeInTheDocument();
  });
});
</code></pre>
<h3 id="hook-tests">Hook Tests</h3>
<pre><code class="lang-typescript">import { renderHookWithProviders, waitFor } from '@/test/utils/hookTestUtils';
import { useProjects } from './useProjects';

describe('useProjects', () =&gt; {
  it('should fetch projects on mount', async () =&gt; {
    const { result } = renderHookWithProviders(() =&gt; useProjects());

    expect(result.current.isLoading).toBe(true);

    await waitFor(() =&gt; {
      expect(result.current.isLoading).toBe(false);
    });

    expect(result.current.projects).toHaveLength(0);
  });

  it('should handle errors gracefully', async () =&gt; {
    // Mock API to return error
    const { result } = renderHookWithProviders(() =&gt; useProjects());

    await waitFor(() =&gt; {
      expect(result.current.error).toBeDefined();
    });
  });
});
</code></pre>
<h3 id="testing-with-react-query">Testing with React Query</h3>
<pre><code class="lang-typescript">import { renderWithProviders, waitFor } from '@/test/utils/testUtils';
import { QueryClient } from '@tanstack/react-query';
import { server } from '@/test/mocks/server';
import { rest } from 'msw';

describe('ProjectList', () =&gt; {
  it('should display projects from API', async () =&gt; {
    // Mock API response
    server.use(
      rest.get('/api/projects', (req, res, ctx) =&gt; {
        return res(ctx.json([
          { id: '1', name: 'Project 1' },
          { id: '2', name: 'Project 2' },
        ]));
      })
    );

    renderWithProviders(&lt;ProjectList /&gt;);

    await waitFor(() =&gt; {
      expect(screen.getByText('Project 1')).toBeInTheDocument();
      expect(screen.getByText('Project 2')).toBeInTheDocument();
    });
  });
});
</code></pre>
<h3 id="e2e-tests-with-playwright">E2E Tests with Playwright</h3>
<pre><code class="lang-typescript">import { test, expect } from '@playwright/test';

test.describe('Video Creation Workflow', () =&gt; {
  test('should create video from wizard', async ({ page }) =&gt; {
    // Navigate to create page
    await page.goto('/create');

    // Fill in form
    await page.fill('input[name=&quot;title&quot;]', 'My Test Video');
    await page.fill('textarea[name=&quot;description&quot;]', 'Test description');

    // Submit
    await page.click('button[type=&quot;submit&quot;]');

    // Verify redirect and success message
    await expect(page).toHaveURL(/\/projects\/\w+/);
    await expect(page.locator('.success-message')).toBeVisible();
  });

  test('should handle validation errors', async ({ page }) =&gt; {
    await page.goto('/create');

    // Submit without filling required fields
    await page.click('button[type=&quot;submit&quot;]');

    // Verify error messages
    await expect(page.locator('.error')).toContainText('Title is required');
  });
});
</code></pre>
<h2 id="test-data-builders">Test Data Builders</h2>
<p>Always use test data builders instead of creating test objects manually:</p>
<h3 id="benefits">Benefits</h3>
<ol>
<li><strong>Consistency</strong>: Same defaults across all tests</li>
<li><strong>Readability</strong>: Fluent interface is self-documenting</li>
<li><strong>Maintainability</strong>: Changes to models require updates in one place</li>
<li><strong>Flexibility</strong>: Easy to customize while keeping defaults</li>
</ol>
<h3 id="creating-a-new-builder">Creating a New Builder</h3>
<pre><code class="lang-csharp">public class MyModelBuilder
{
    private string _id = Guid.NewGuid().ToString();
    private string _name = &quot;Default Name&quot;;
    private DateTime _createdAt = DateTime.UtcNow;

    public MyModelBuilder WithId(string id)
    {
        _id = id;
        return this;
    }

    public MyModelBuilder WithName(string name)
    {
        _name = name;
        return this;
    }

    public MyModelBuilder CreatedAt(DateTime createdAt)
    {
        _createdAt = createdAt;
        return this;
    }

    public MyModel Build()
    {
        return new MyModel
        {
            Id = _id,
            Name = _name,
            CreatedAt = _createdAt
        };
    }
}
</code></pre>
<h2 id="integration-tests-1">Integration Tests</h2>
<p>Integration tests verify that multiple components work together correctly.</p>
<h3 id="api-integration-tests">API Integration Tests</h3>
<pre><code class="lang-csharp">[Collection(&quot;Integration Tests&quot;)]
public class VideoWorkflowTests : IntegrationTestBase
{
    public VideoWorkflowTests(WebApplicationFactory&lt;Program&gt; factory)
        : base(factory)
    {
    }

    [Fact]
    public async Task CompleteVideoWorkflow_CreatesToCompletion()
    {
        // Create project
        var project = await CreateProjectAsync();

        // Create video job
        var job = await CreateVideoJobAsync(project.Id);

        // Process job
        await ProcessJobAsync(job.Id);

        // Verify completion
        var result = await GetJobStatusAsync(job.Id);
        Assert.Equal(JobStatus.Completed, result.Status);
    }
}
</code></pre>
<h2 id="performance-tests">Performance Tests</h2>
<p>Performance tests ensure operations complete within acceptable time limits.</p>
<pre><code class="lang-csharp">public class TimelinePerformanceTests : PerformanceTestBase
{
    public TimelinePerformanceTests(ITestOutputHelper output) 
        : base(output)
    {
    }

    [Fact]
    public async Task TimelineRendering_CompletesUnderThreshold()
    {
        // Arrange
        var timeline = new TimelineBuilder()
            .WithDuration(300.0) // 5 minutes
            .WithDefaultVideoTrack()
            .WithDefaultAudioTrack()
            .Build();

        var threshold = TimeSpan.FromMilliseconds(100);

        // Act
        var duration = await MeasureAsync(async () =&gt;
        {
            await RenderTimelineAsync(timeline);
        }, &quot;Timeline Rendering&quot;);

        // Assert
        AssertPerformance(duration, threshold);
        PrintPerformanceSummary();
    }
}
</code></pre>
<h2 id="best-practices">Best Practices</h2>
<h3 id="general">General</h3>
<ol>
<li><strong>Arrange-Act-Assert Pattern</strong>: Structure all tests this way</li>
<li><strong>One Assertion Per Test</strong>: Focus on testing one thing</li>
<li><strong>Descriptive Test Names</strong>: Explain what is being tested and expected</li>
<li><strong>Independent Tests</strong>: Tests should not depend on each other</li>
<li><strong>Fast Tests</strong>: Keep unit tests fast (&lt; 100ms)</li>
</ol>
<h3 id="test-coverage">Test Coverage</h3>
<ul>
<li><strong>Aim for 80% coverage</strong> minimum</li>
<li><strong>Focus on critical paths</strong> first</li>
<li><strong>Test edge cases</strong> and error conditions</li>
<li><strong>Don't test framework code</strong> (e.g., React internals)</li>
</ul>
<h3 id="mocking">Mocking</h3>
<pre><code class="lang-csharp">// Mock setup
_mockService
    .Setup(s =&gt; s.GetAsync(It.IsAny&lt;string&gt;()))
    .ReturnsAsync(expectedResult);

// Verify calls
_mockService.Verify(
    s =&gt; s.GetAsync(&quot;123&quot;),
    Times.Once,
    &quot;Service should be called exactly once&quot;
);

// Verify no unexpected calls
_mockService.VerifyNoOtherCalls();
</code></pre>
<h3 id="async-testing">Async Testing</h3>
<pre><code class="lang-csharp">// Backend
[Fact]
public async Task AsyncMethod_CompletesSuccessfully()
{
    var result = await _sut.DoWorkAsync();
    Assert.NotNull(result);
}

// Frontend
it('should handle async operation', async () =&gt; {
    renderWithProviders(&lt;AsyncComponent /&gt;);
    
    await waitFor(() =&gt; {
        expect(screen.getByText('Loaded')).toBeInTheDocument();
    });
});
</code></pre>
<h3 id="cleanup">Cleanup</h3>
<pre><code class="lang-csharp">// Backend
public void Dispose()
{
    _scope?.Dispose();
    _context?.Dispose();
}

// Frontend
afterEach(() =&gt; {
    jest.clearAllMocks();
    cleanup();
});
</code></pre>
<h3 id="avoiding-flaky-tests">Avoiding Flaky Tests</h3>
<ol>
<li><strong>Avoid timing dependencies</strong>: Use <code>waitFor</code> instead of fixed delays</li>
<li><strong>Clean up resources</strong>: Dispose properly</li>
<li><strong>Use deterministic data</strong>: Avoid random data in assertions</li>
<li><strong>Isolate tests</strong>: Don't share state between tests</li>
<li><strong>Mock external dependencies</strong>: Don't rely on real APIs</li>
</ol>
<h2 id="code-examples-repository">Code Examples Repository</h2>
<p>See the <code>Aura.Tests/Examples/</code> directory for complete, runnable examples of:</p>
<ul>
<li>Unit tests</li>
<li>Integration tests</li>
<li>Performance tests</li>
<li>E2E tests</li>
<li>Custom matchers and utilities</li>
</ul>
<h2 id="further-reading">Further Reading</h2>
<ul>
<li><a href="https://xunit.net/">xUnit Documentation</a></li>
<li><a href="https://github.com/moq/moq4/wiki/Quickstart">Moq Quickstart</a></li>
<li><a href="https://fluentassertions.com/introduction">FluentAssertions Documentation</a></li>
<li><a href="https://testing-library.com/docs/guiding-principles">Testing Library Best Practices</a></li>
<li><a href="https://playwright.dev/docs/best-practices">Playwright Best Practices</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/Coffee285/aura-video-studio/blob/main/docs/testing/TEST_WRITING_GUIDE.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          © 2025 Aura Video Studio. Documentation built with DocFX.
        </div>
      </div>
    </footer>
  </body>
</html>
